<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Stellar Logistics</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            font-family: 'Arial', sans-serif;
            background-color: #000;
            color: #fff;
        }
        #gameContainer {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        #ui {
            position: absolute;
            top: 10px;
            left: 10px;
            z-index: 10;
            background-color: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 5px;
            max-width: 300px;
        }
        #minimap {
            position: absolute;
            top: 10px;
            right: 10px;
            width: 250px;
            height: 250px;
            background-color: rgba(0, 0, 0, 0.7);
            border-radius: 5px;
            z-index: 10;
            border: 1px solid #3498db;
            overflow: hidden;
        }
        #fuelDisplay {
            font-size: 18px;
            margin-bottom: 10px;
        }
        button {
            background-color: #2c3e50;
            color: #ecf0f1;
            border: none;
            padding: 8px 15px;
            margin: 5px;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.3s;
        }
        button:hover {
            background-color: #34495e;
        }
        button:disabled {
            background-color: #7f8c8d;
            cursor: not-allowed;
        }
        #pathOptions {
            margin-top: 10px;
        }
        #gameOver {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.8);
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            display: none;
            z-index: 20;
            max-width: 500px;
        }
        h2 {
            color: #3498db;
        }
        #gameOver button {
            background-color: #2980b9;
            font-size: 16px;
            padding: 10px 20px;
        }
        /* Reset buttons */
        #resetButtons {
            display: flex;
            justify-content: space-between;
            margin-top: 10px;
        }
        #undoLastMove {
            background-color: #e67e22;
        }
        #restartGame {
            background-color: #c0392b;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <div id="ui">
            <h2>Stellar Logistics</h2>
            <div id="fuelDisplay">Fuel Remaining: 1000</div>
            <div id="currentPosition">Current: Start Base</div>
            <div id="visitedPlanets">Planets Visited: 0/6</div>
            <div id="pathOptions"></div>
            <div id="resetButtons">
                <button id="undoLastMove">Undo Last Move</button>
                <button id="restartGame">Restart Game</button>
            </div>
        </div>
        <div id="minimap"></div>
        <div id="gameOver">
            <h2>Mission Complete!</h2>
            <div id="results">
                <p>Your fuel usage: <span id="playerFuel">0</span></p>
                <p>Optimal fuel usage: <span id="optimalFuel">0</span></p>
                <p>Efficiency rating: <span id="efficiency">0%</span></p>
            </div>
            <button id="restartButton">Start New Mission</button>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Game variables
        const TOTAL_PLANETS = 6;
        const START_FUEL = 1000;
        let currentFuel = START_FUEL;
        let currentPlanet = 'Start Base';
        let visitedPlanets = new Set();
        let usedPaths = new Set(); // Tracks used paths
        let gameActive = true;
        let planets = {};
        let optimalPath = null;
        let travelHistory = []; // Array to store the travel history for undo functionality
        let shipTrails = []; // Array to store the ship's trail objects
        
        // Minimap variables
        let minimapScene, minimapCamera, minimapRenderer;
        let minimapShip;
        let minimapTrails = []; // For trails in minimap
        let minimapPlanets = {};
        
        // Planet data - Reorganized in hexagon pattern
        const planetData = {
            'Start Base': { color: 0xFFFFFF, size: 15, position: { x: 0, y: 0, z: 0 } },
            'Neonyx': { color: 0x00FFFF, size: 30, position: { x: -150, y: 30, z: -86.6 } },
            'Crimsonova': { color: 0xFF5555, size: 40, position: { x: 150, y: -20, z: -86.6 } },
            'Emeraldian': { color: 0x55FF55, size: 25, position: { x: -150, y: 50, z: 86.6 } },
            'Aurorion': { color: 0xFF55FF, size: 35, position: { x: 150, y: -40, z: 86.6 } },
            'Cobaltrix': { color: 0x5555FF, size: 45, position: { x: 0, y: -30, z: -173.2 } },
            'Solarium': { color: 0xFFFF55, size: 50, position: { x: 0, y: 60, z: 173.2 } }
        };

        // Create distances between planets
        const distances = {};
        
        // Calculate distances between planets
        function calculateDistances() {
            const planetNames = Object.keys(planetData);
            
            for (let i = 0; i < planetNames.length; i++) {
                distances[planetNames[i]] = {};
                
                for (let j = 0; j < planetNames.length; j++) {
                    if (i !== j) {
                        const p1 = planetData[planetNames[i]].position;
                        const p2 = planetData[planetNames[j]].position;
                        
                        // Calculate Euclidean distance
                        const distance = Math.sqrt(
                            Math.pow(p1.x - p2.x, 2) + 
                            Math.pow(p1.y - p2.y, 2) + 
                            Math.pow(p1.z - p2.z, 2)
                        );
                        
                        // Fuel cost is distance divided by 2
                        distances[planetNames[i]][planetNames[j]] = Math.round(distance / 2);
                    }
                }
            }
        }
        
        // Function to find optimal path (using brute force for small problem)
        function findOptimalPath() {
            const planetNames = Object.keys(planetData).filter(name => name !== 'Start Base');
            
            // Generate all permutations of planets
            function permute(arr, start = 0) {
                if (start === arr.length - 1) {
                    return [arr.slice()];
                }
                
                let result = [];
                for (let i = start; i < arr.length; i++) {
                    [arr[start], arr[i]] = [arr[i], arr[start]];
                    result = result.concat(permute(arr, start + 1));
                    [arr[start], arr[i]] = [arr[i], arr[start]]; // backtrack
                }
                
                return result;
            }
            
            const permutations = permute(planetNames);
            let minFuel = Infinity;
            let bestPath = null;
            
            // Evaluate each permutation
            for (const perm of permutations) {
                let fuel = 0;
                let currentLocation = 'Start Base';
                
                // Calculate fuel for this path
                for (const planet of perm) {
                    fuel += distances[currentLocation][planet];
                    currentLocation = planet;
                }
                
                // Add return to start base
                fuel += distances[currentLocation]['Start Base'];
                
                // Update if this is better
                if (fuel < minFuel) {
                    minFuel = fuel;
                    bestPath = ['Start Base', ...perm, 'Start Base'];
                }
            }
            
            return { path: bestPath, fuel: minFuel };
        }

        // Three.js setup
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 2000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        
        // Define playerShip early
        let playerShip;

        renderer.setSize(window.innerWidth, window.innerHeight);
        document.getElementById('gameContainer').appendChild(renderer.domElement);
        
        // Camera parameters for third-person view
        const cameraOffset = new THREE.Vector3(-30, 15, 0); // Position behind and slightly above ship
        let cameraTarget = new THREE.Vector3(); // What the camera looks at

        // Lighting
        const ambientLight = new THREE.AmbientLight(0x333333);
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
        directionalLight.position.set(5, 3, 5);
        scene.add(directionalLight);

        // Create stars
        function createStars() {
            const starsGeometry = new THREE.BufferGeometry();
            const starsMaterial = new THREE.PointsMaterial({
                color: 0xffffff,
                size: 1,
                sizeAttenuation: false
            });

            const starsVertices = [];
            for (let i = 0; i < 10000; i++) {
                const x = (Math.random() - 0.5) * 2000;
                const y = (Math.random() - 0.5) * 2000;
                const z = (Math.random() - 0.5) * 2000;
                starsVertices.push(x, y, z);
            }

            starsGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starsVertices, 3));
            const stars = new THREE.Points(starsGeometry, starsMaterial);
            scene.add(stars);
            
            // Create stars for minimap
            const minimapStarsGeometry = new THREE.BufferGeometry();
            const minimapStarsVertices = [];
            for (let i = 0; i < 500; i++) {
                const x = (Math.random() - 0.5) * 2000;
                const y = (Math.random() - 0.5) * 2000;
                const z = (Math.random() - 0.5) * 2000;
                minimapStarsVertices.push(x, y, z);
            }
            minimapStarsGeometry.setAttribute('position', new THREE.Float32BufferAttribute(minimapStarsVertices, 3));
            const minimapStars = new THREE.Points(minimapStarsGeometry, starsMaterial);
            minimapScene.add(minimapStars);
        }

        // Create space debris
        function createDebris() {
            for (let i = 0; i < 100; i++) {
                const geometry = new THREE.TetrahedronGeometry(Math.random() * 3 + 1, 0);
                const material = new THREE.MeshStandardMaterial({
                    color: 0x888888,
                    roughness: 0.8,
                    metalness: 0.2
                });
                const debris = new THREE.Mesh(geometry, material);
                
                // Position debris randomly in space
                debris.position.set(
                    (Math.random() - 0.5) * 1000,
                    (Math.random() - 0.5) * 1000,
                    (Math.random() - 0.5) * 1000
                );
                
                // Random rotation
                debris.rotation.set(
                    Math.random() * Math.PI * 2,
                    Math.random() * Math.PI * 2,
                    Math.random() * Math.PI * 2
                );
                
                scene.add(debris);
            }
        }

        // Create pirate ships
        function createPirateShips() {
            for (let i = 0; i < 10; i++) {
                // Ship body
                const body = new THREE.Group();
                
                // Main hull - using CylinderGeometry instead of CapsuleGeometry
                const hullGeometry = new THREE.CylinderGeometry(3, 3, 10, 12);
                const hullMaterial = new THREE.MeshStandardMaterial({
                    color: 0x333333,
                    roughness: 0.7,
                    metalness: 0.3
                });
                const hull = new THREE.Mesh(hullGeometry, hullMaterial);
                hull.rotation.z = Math.PI / 2;
                body.add(hull);
                
                // Wings
                const wingGeometry = new THREE.BoxGeometry(10, 1, 3);
                const wingMaterial = new THREE.MeshStandardMaterial({
                    color: 0x444444,
                    roughness: 0.6,
                    metalness: 0.4
                });
                const wing = new THREE.Mesh(wingGeometry, wingMaterial);
                wing.position.y = -1;
                body.add(wing);
                
                // Cockpit
                const cockpitGeometry = new THREE.SphereGeometry(2, 8, 8, 0, Math.PI * 2, 0, Math.PI / 2);
                const cockpitMaterial = new THREE.MeshStandardMaterial({
                    color: 0x990000,
                    roughness: 0.2,
                    metalness: 0.8
                });
                const cockpit = new THREE.Mesh(cockpitGeometry, cockpitMaterial);
                cockpit.position.set(3, 0, 0);
                cockpit.rotation.z = Math.PI / 2;
                body.add(cockpit);
                
                // Position ship randomly in space
                body.position.set(
                    (Math.random() - 0.5) * 800,
                    (Math.random() - 0.5) * 800,
                    (Math.random() - 0.5) * 800
                );
                
                // Random rotation
                body.rotation.set(
                    Math.random() * Math.PI * 2,
                    Math.random() * Math.PI * 2,
                    Math.random() * Math.PI * 2
                );
                
                scene.add(body);
            }
        }

        // Create the Millennium Falcon-like ship
        function createPlayerShip() {
            const ship = new THREE.Group();
            
            // Main body - flattened disk
            const bodyGeometry = new THREE.CylinderGeometry(10, 10, 3, 16);
            const bodyMaterial = new THREE.MeshStandardMaterial({
                color: 0xcccccc,
                roughness: 0.7,
                metalness: 0.5
            });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.rotation.x = Math.PI / 2;
            ship.add(body);
            
            // Front mandibles
            const mandibleGeometry = new THREE.BoxGeometry(15, 2, 4);
            const mandibleMaterial = new THREE.MeshStandardMaterial({
                color: 0xaaaaaa,
                roughness: 0.6,
                metalness: 0.4
            });
            
            const leftMandible = new THREE.Mesh(mandibleGeometry, mandibleMaterial);
            leftMandible.position.set(8, 0, -5);
            leftMandible.rotation.y = Math.PI / 12;
            ship.add(leftMandible);
            
            const rightMandible = new THREE.Mesh(mandibleGeometry, mandibleMaterial);
            rightMandible.position.set(8, 0, 5);
            rightMandible.rotation.y = -Math.PI / 12;
            ship.add(rightMandible);
            
            // Cockpit
            const cockpitGeometry = new THREE.SphereGeometry(3, 8, 8, 0, Math.PI * 2, 0, Math.PI / 2);
            const cockpitMaterial = new THREE.MeshStandardMaterial({
                color: 0x5555ff,
                roughness: 0.2,
                metalness: 0.8
            });
            const cockpit = new THREE.Mesh(cockpitGeometry, cockpitMaterial);
            cockpit.position.set(0, 2, 5);
            cockpit.rotation.x = -Math.PI / 2;
            ship.add(cockpit);
            
            // Rear engine glow
            const engineGlowGeometry = new THREE.RingGeometry(2, 4, 16);
            const engineGlowMaterial = new THREE.MeshBasicMaterial({
                color: 0x55aaff,
                side: THREE.DoubleSide
            });
            const engineGlow = new THREE.Mesh(engineGlowGeometry, engineGlowMaterial);
            engineGlow.position.set(-10, 0, 0);
            engineGlow.rotation.y = Math.PI / 2;
            ship.add(engineGlow);
            
            // Radar dish
            const radarGeometry = new THREE.CylinderGeometry(2, 2, 0.5, 16);
            const radarMaterial = new THREE.MeshStandardMaterial({
                color: 0x888888,
                roughness: 0.5,
                metalness: 0.7
            });
            const radar = new THREE.Mesh(radarGeometry, radarMaterial);
            radar.position.set(-5, 3, 0);
            radar.rotation.x = Math.PI / 2;
            ship.add(radar);
            
            // Add details - small boxes
            for (let i = 0; i < 10; i++) {
                const detailGeometry = new THREE.BoxGeometry(
                    Math.random() * 2 + 1,
                    Math.random() * 2 + 0.5,
                    Math.random() * 2 + 0.5
                );
                const detailMaterial = new THREE.MeshStandardMaterial({
                    color: 0x999999,
                    roughness: 0.7,
                    metalness: 0.3
                });
                const detail = new THREE.Mesh(detailGeometry, detailMaterial);
                
                // Position details randomly on the ship body
                const theta = Math.random() * Math.PI * 2;
                const radius = Math.random() * 8;
                detail.position.set(
                    (Math.random() - 0.5) * 10,
                    Math.sin(theta) * radius * 0.3 + 1,
                    Math.cos(theta) * radius
                );
                
                ship.add(detail);
            }
            
            // Scale the ship down to a reasonable size
            ship.scale.set(0.5, 0.5, 0.5);
            
            // Define the world-space "forward" direction for the ship
            ship.userData.forward = new THREE.Vector3(1, 0, 0);
            
            return ship;
        }
        
        // Create a simplified ship for the minimap
        function createMinimapShip() {
            const ship = new THREE.Group();
            
            // Simple ship representation - just a small cone
            const geometry = new THREE.ConeGeometry(3, 6, 4);
            const material = new THREE.MeshBasicMaterial({ color: 0xFFFFFF });
            const cone = new THREE.Mesh(geometry, material);
            cone.rotation.x = Math.PI / 2;
            ship.add(cone);
            
            // Scale the minimap ship
            ship.scale.set(1, 1, 1);
            
            return ship;
        }

        // Create a planet
        function createPlanet(name, data) {
            const planetGroup = new THREE.Group();
            
            // Main planet geometry
            const geometry = new THREE.SphereGeometry(data.size, 32, 32);
            
            // Create a texture with a gradient and some noise
            const canvas = document.createElement('canvas');
            canvas.width = 512;
            canvas.height = 512;
            const ctx = canvas.getContext('2d');
            
            // Convert hex color to RGB
            const r = (data.color >> 16) & 255;
            const g = (data.color >> 8) & 255;
            const b = data.color & 255;
            
            // Create gradient
            const gradient = ctx.createRadialGradient(256, 256, 0, 256, 256, 256);
            gradient.addColorStop(0, `rgb(${r + 50}, ${g + 50}, ${b + 50})`);
            gradient.addColorStop(0.7, `rgb(${r}, ${g}, ${b})`);
            gradient.addColorStop(1, `rgb(${r - 50}, ${g - 50}, ${b - 50})`);
            
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, 512, 512);
            
            // Add some noise for texture
            ctx.globalCompositeOperation = 'overlay';
            for (let i = 0; i < 5000; i++) {
                const x = Math.random() * 512;
                const y = Math.random() * 512;
                const size = Math.random() * 2 + 0.5;
                ctx.fillStyle = `rgba(255, 255, 255, ${Math.random() * 0.2})`;
                ctx.fillRect(x, y, size, size);
            }
            
            const texture = new THREE.CanvasTexture(canvas);
            
            // Planet material with glow effect
            const material = new THREE.MeshStandardMaterial({
                map: texture,
                roughness: 0.7,
                metalness: 0.3
            });
            
            const planet = new THREE.Mesh(geometry, material);
            planetGroup.add(planet);
            
            // Add glow effect
            const glowGeometry = new THREE.SphereGeometry(data.size * 1.2, 32, 32);
            const glowMaterial = new THREE.MeshBasicMaterial({
                color: data.color,
                transparent: true,
                opacity: 0.2,
                side: THREE.BackSide
            });
            const glow = new THREE.Mesh(glowGeometry, glowMaterial);
            planetGroup.add(glow);
            
            // If it's not the start base, add some moons
            if (name !== 'Start Base') {
                const moonCount = Math.floor(Math.random() * 3) + 1;
                
                for (let i = 0; i < moonCount; i++) {
                    const moonSize = data.size * (Math.random() * 0.15 + 0.05);
                    const moonGeometry = new THREE.SphereGeometry(moonSize, 16, 16);
                    const moonMaterial = new THREE.MeshStandardMaterial({
                        color: 0xaaaaaa,
                        roughness: 0.8,
                        metalness: 0.2
                    });
                    const moon = new THREE.Mesh(moonGeometry, moonMaterial);
                    
                    // Position moon in orbit
                    const theta = Math.random() * Math.PI * 2;
                    const orbitRadius = data.size * (Math.random() * 0.7 + 1.5);
                    moon.position.set(
                        Math.sin(theta) * orbitRadius,
                        (Math.random() - 0.5) * orbitRadius * 0.5,
                        Math.cos(theta) * orbitRadius
                    );
                    
                    planetGroup.add(moon);
                }
            }
            
            // For the start base, create a space station
            if (name === 'Start Base') {
                // Central hub
                const hubGeometry = new THREE.SphereGeometry(5, 16, 16);
                const hubMaterial = new THREE.MeshStandardMaterial({
                    color: 0xaaaaaa,
                    roughness: 0.6,
                    metalness: 0.7
                });
                const hub = new THREE.Mesh(hubGeometry, hubMaterial);
                planetGroup.add(hub);
                
                // Spokes/arms extending out
                for (let i = 0; i < 4; i++) {
                    const armGeometry = new THREE.CylinderGeometry(1, 1, 20, 8);
                    const armMaterial = new THREE.MeshStandardMaterial({
                        color: 0x888888,
                        roughness: 0.7,
                        metalness: 0.5
                    });
                    const arm = new THREE.Mesh(armGeometry, armMaterial);
                    
                    arm.position.set(0, 0, 0);
                    arm.rotation.z = Math.PI / 2;
                    arm.rotation.y = (Math.PI / 2) * i;
                    
                    planetGroup.add(arm);
                    
                    // Add modules to the ends of arms
                    const moduleGeometry = new THREE.BoxGeometry(8, 4, 4);
                    const moduleMaterial = new THREE.MeshStandardMaterial({
                        color: 0x666666,
                        roughness: 0.6,
                        metalness: 0.6
                    });
                    const module = new THREE.Mesh(moduleGeometry, moduleMaterial);
                    
                    // Position at the end of arm
                    module.position.set(13, 0, 0);
                    module.rotation.y = (Math.PI / 2) * i;
                    
                    planetGroup.add(module);
                }
                
                // Landing pad
                const padGeometry = new THREE.CylinderGeometry(8, 8, 1, 16);
                const padMaterial = new THREE.MeshStandardMaterial({
                    color: 0x444444,
                    roughness: 0.8,
                    metalness: 0.3
                });
                const pad = new THREE.Mesh(padGeometry, padMaterial);
                pad.position.set(0, -7, 0);
                planetGroup.add(pad);
                
                // Lights around the landing pad
                for (let i = 0; i < 8; i++) {
                    const lightGeometry = new THREE.SphereGeometry(0.5, 8, 8);
                    const lightMaterial = new THREE.MeshBasicMaterial({
                        color: 0xffaa00
                    });
                    const light = new THREE.Mesh(lightGeometry, lightMaterial);
                    
                    const theta = (Math.PI * 2 / 8) * i;
                    light.position.set(
                        Math.sin(theta) * 7.5,
                        -6.5,
                        Math.cos(theta) * 7.5
                    );
                    
                    planetGroup.add(light);
                }
            }
            
            // Name label
            const textCanvas = document.createElement('canvas');
            textCanvas.width = 256;
            textCanvas.height = 64;
            const textCtx = textCanvas.getContext('2d');
            textCtx.fillStyle = '#ffffff';
            textCtx.font = '24px Arial';
            textCtx.textAlign = 'center';
            textCtx.fillText(name, 128, 40);
            
            const textTexture = new THREE.CanvasTexture(textCanvas);
            const spriteMaterial = new THREE.SpriteMaterial({ map: textTexture });
            const sprite = new THREE.Sprite(spriteMaterial);
            sprite.position.set(0, data.size + 10, 0);
            sprite.scale.set(20, 5, 1);
            planetGroup.add(sprite);
            
            // Position the planet
            planetGroup.position.set(data.position.x, data.position.y, data.position.z);
            
            // Add slight rotation
            planetGroup.rotation.set(
                Math.random() * 0.2,
                Math.random() * 0.2,
                Math.random() * 0.2
            );
            
            scene.add(planetGroup);
            
            return {
                object: planetGroup,
                position: data.position,
                size: data.size
            };
        }
        
        // Create simplified minimap planets
        function createMinimapPlanet(name, data) {
            const planetGroup = new THREE.Group();
            
            // Simple sphere geometry for the planet
            const geometry = new THREE.SphereGeometry(data.size / 2, 16, 16);
            const material = new THREE.MeshBasicMaterial({ color: data.color });
            const planet = new THREE.Mesh(geometry, material);
            planetGroup.add(planet);
            
            // Label for the planet
            const textCanvas = document.createElement('canvas');
            textCanvas.width = 128;
            textCanvas.height = 32;
            const textCtx = textCanvas.getContext('2d');
            textCtx.fillStyle = '#ffffff';
            textCtx.font = '12px Arial';
            textCtx.textAlign = 'center';
            textCtx.fillText(name, 64, 20);
            
            const textTexture = new THREE.CanvasTexture(textCanvas);
            const spriteMaterial = new THREE.SpriteMaterial({ map: textTexture });
            const sprite = new THREE.Sprite(spriteMaterial);
            sprite.position.set(0, data.size / 2 + 5, 0);
            sprite.scale.set(10, 3, 1);
            planetGroup.add(sprite);
            
            // Position the minimap planet
            planetGroup.position.set(data.position.x, data.position.y, data.position.z);
            
            // Add to minimap scene
            minimapScene.add(planetGroup);
            
            // Add click detection for minimap planets
            planetGroup.userData = { name: name }; // Store name for click detection
            
            return {
                object: planetGroup,
                position: data.position,
                size: data.size / 2
            };
        }

        // Create all planets
        function createPlanets() {
            for (const [name, data] of Object.entries(planetData)) {
                planets[name] = createPlanet(name, data);
                minimapPlanets[name] = createMinimapPlanet(name, data);
            }
        }
        
        // Create a travel trail
        function createTrail(startPos, endPos, color = 0x3498db) {
            // Create a curve between the two points
            const curve = new THREE.LineCurve3(
                new THREE.Vector3(startPos.x, startPos.y, startPos.z),
                new THREE.Vector3(endPos.x, endPos.y, endPos.z)
            );
            
            const points = curve.getPoints(50);
            const geometry = new THREE.BufferGeometry().setFromPoints(points);
            
            const material = new THREE.LineBasicMaterial({ 
                color: color,
                linewidth: 3,
                opacity: 0.7,
                transparent: true
            });
            
            const line = new THREE.Line(geometry, material);
            scene.add(line);
            shipTrails.push(line);
            
            // Create the same trail for minimap
            const minimapMaterial = new THREE.LineBasicMaterial({ 
                color: color,
                linewidth: 5,
                opacity: 0.9,
                transparent: true
            });
            
            const minimapLine = new THREE.Line(geometry, minimapMaterial);
            minimapScene.add(minimapLine);
            minimapTrails.push(minimapLine);
            
            return { mainLine: line, minimapLine: minimapLine };
        }
        
        // Initialize the game
        function initializeGame() {
            // Set up the minimap first
            setupMinimap();
            
            calculateDistances();
            optimalPath = findOptimalPath();
            createStars();
            createDebris();
            createPirateShips();
            createPlanets();
            
            // Set up initial camera position (before updating with ship position)
            camera.position.set(0, 50, 100);
            camera.lookAt(0, 0, 0);
            
            // Create player ship
            playerShip = createPlayerShip();
            playerShip.position.copy(planets['Start Base'].position);
            playerShip.position.y += 15; // Position above the start base
            scene.add(playerShip);
            
            // Create minimap ship
            minimapShip = createMinimapShip();
            minimapShip.position.copy(planets['Start Base'].position);
            minimapShip.position.y += 15;
            minimapScene.add(minimapShip);
            
            // Now update camera to follow ship
            updateCameraPosition();
            
            // Add animation for the ship
            playerShip.userData = {
                animating: false,
                startPosition: new THREE.Vector3(),
                targetPosition: new THREE.Vector3(),
                animationProgress: 0,
                animationDuration: 3 // seconds
            };
            
            minimapShip.userData = {
                animating: false,
                startPosition: new THREE.Vector3(),
                targetPosition: new THREE.Vector3(),
                animationProgress: 0,
                animationDuration: 3 // seconds
            };
            
            // Update UI
            updatePathOptions();
            
            // Start animation loop
            animate();
        }
        
        // Initialize minimap
        function setupMinimap() {
            // Create minimap container
            const minimapContainer = document.getElementById('minimap');
            
            // Setup minimap renderer
            minimapScene = new THREE.Scene();
            minimapCamera = new THREE.PerspectiveCamera(60, 1, 1, 2000);
            minimapRenderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            minimapRenderer.setSize(250, 250);
            minimapContainer.appendChild(minimapRenderer.domElement);
            
            // Position minimap camera to show the entire space
            minimapCamera.position.set(0, 400, 0);
            minimapCamera.lookAt(0, 0, 0);
            
            // Add minimap lighting
            const minimapAmbientLight = new THREE.AmbientLight(0x666666);
            minimapScene.add(minimapAmbientLight);
            
            // Add event listener for minimap clicks
            minimapRenderer.domElement.addEventListener('click', onMinimapClick);
        }
        
        // Handle minimap clicks
        function onMinimapClick(event) {
            if (!gameActive) return;
            
            // Calculate mouse position in normalized device coordinates (-1 to +1)
            const rect = minimapRenderer.domElement.getBoundingClientRect();
            const x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            const y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
            
            const raycaster = new THREE.Raycaster();
            const mouse = new THREE.Vector2(x, y);
            
            // Update the picking ray with the camera and mouse position
            raycaster.setFromCamera(mouse, minimapCamera);
            
            // Calculate objects intersecting the picking ray
            const intersects = raycaster.intersectObjects(minimapScene.children, true);
            
            // Find the first clicked planet
            for (let i = 0; i < intersects.length; i++) {
                // Traverse up to find the group with userData
                let object = intersects[i].object;
                while (object && !object.userData.name) {
                    object = object.parent;
                }
                
                if (object && object.userData.name) {
                    const planetName = object.userData.name;
                    
                    // Check if this is a valid destination
                    const destinations = Object.keys(planetData).filter(name => {
                        // Can't go to current planet or already visited planets
                        if (name === currentPlanet || (name !== 'Start Base' && visitedPlanets.has(name))) {
                            return false;
                        }
                        
                        // Can only return to Start Base after visiting all planets
                        if (name === 'Start Base' && visitedPlanets.size < TOTAL_PLANETS) {
                            return false;
                        }
                        
                        // Check if path has been used
                        const pathKey = `${currentPlanet}-${name}`;
                        if (usedPaths.has(pathKey)) {
                            return false;
                        }
                        
                        return true;
                    });
                    
                    if (destinations.includes(planetName)) {
                        const fuelCost = distances[currentPlanet][planetName];
                        if (fuelCost <= currentFuel) {
                            travel(planetName);
                        }
                    }
                    
                    break;
                }
            }
        }

        // Update path options in UI
        function updatePathOptions() {
            const pathOptionsDiv = document.getElementById('pathOptions');
            pathOptionsDiv.innerHTML = '<h3>Available Routes:</h3>';
            
            // Get all possible destinations
            const destinations = Object.keys(planetData).filter(name => {
                // Can't go to current planet or already visited planets
                if (name === currentPlanet || (name !== 'Start Base' && visitedPlanets.has(name))) {
                    return false;
                }
                
                // Can only return to Start Base after visiting all planets
                if (name === 'Start Base' && visitedPlanets.size < TOTAL_PLANETS) {
                    return false;
                }
                
                // Check if path has been used
                const pathKey = `${currentPlanet}-${name}`;
                if (usedPaths.has(pathKey)) {
                    return false;
                }
                
                return true;
            });
            
            // End game if no more destinations
            if (destinations.length === 0 && visitedPlanets.size < TOTAL_PLANETS) {
                endGame(false);
                return;
            }
            
            // Create buttons for each destination
            for (const dest of destinations) {
                const fuelCost = distances[currentPlanet][dest];
                const button = document.createElement('button');
                button.textContent = `${dest} (Fuel: ${fuelCost})`;
                button.disabled = fuelCost > currentFuel;
                
                button.addEventListener('click', () => {
                    if (gameActive) {
                        travel(dest);
                    }
                });
                
                pathOptionsDiv.appendChild(button);
            }
        }

        // Travel to a new planet
        function travel(destination) {
            // Save current state for undo
            travelHistory.push({
                fromPlanet: currentPlanet,
                toPlanet: destination,
                fuelBefore: currentFuel,
                visitedBefore: new Set(visitedPlanets),
                usedPathsBefore: new Set(usedPaths)
            });
            
            // Mark path as used
            const pathKey = `${currentPlanet}-${destination}`;
            usedPaths.add(pathKey);
            
            // Draw trail
            const startPos = planets[currentPlanet].position;
            const endPos = planets[destination].position;
            createTrail(startPos, endPos);
            
            // Update fuel
            const fuelCost = distances[currentPlanet][destination];
            currentFuel -= fuelCost;
            document.getElementById('fuelDisplay').textContent = `Fuel Remaining: ${currentFuel}`;
            
            // If not the start base, add to visited planets
            if (destination !== 'Start Base') {
                visitedPlanets.add(destination);
                document.getElementById('visitedPlanets').textContent = `Planets Visited: ${visitedPlanets.size}/${TOTAL_PLANETS}`;
            }
            
            // Update current position
            currentPlanet = destination;
            document.getElementById('currentPosition').textContent = `Current: ${currentPlanet}`;
            
            // Check if game is complete
            if (destination === 'Start Base' && visitedPlanets.size === TOTAL_PLANETS) {
                endGame(true);
                return;
            }
            
            // Check if out of fuel
            if (currentFuel <= 0) {
                endGame(false);
                return;
            }
            
            // Animate ship movement
            animateShipMovement(planets[destination].position);
            
            // Update path options
            updatePathOptions();
        }
        
        // Undo last move
        function undoLastMove() {
            if (travelHistory.length === 0 || !gameActive) return;
            
            const lastMove = travelHistory.pop();
            
            // Restore state
            currentPlanet = lastMove.fromPlanet;
            currentFuel = lastMove.fuelBefore;
            visitedPlanets = new Set(lastMove.visitedBefore);
            usedPaths = new Set(lastMove.usedPathsBefore);
            
            // Remove the last trail
            if (shipTrails.length > 0) {
                const lastTrail = shipTrails.pop();
                scene.remove(lastTrail);
                
                const lastMinimapTrail = minimapTrails.pop();
                minimapScene.remove(lastMinimapTrail);
            }
            
            // Update UI
            document.getElementById('fuelDisplay').textContent = `Fuel Remaining: ${currentFuel}`;
            document.getElementById('currentPosition').textContent = `Current: ${currentPlanet}`;
            document.getElementById('visitedPlanets').textContent = `Planets Visited: ${visitedPlanets.size}/${TOTAL_PLANETS}`;
            
            // Move ship back
            animateShipMovement(planets[currentPlanet].position);
            
            // Update path options
            updatePathOptions();
        }

        // Animate ship movement
        function animateShipMovement(targetPosition) {
            const shipData = playerShip.userData;
            shipData.animating = true;
            shipData.startPosition.copy(playerShip.position);
            
            // Set target position slightly above the planet
            shipData.targetPosition.copy(targetPosition);
            shipData.targetPosition.y += planets[currentPlanet].size + 10;
            
            shipData.animationProgress = 0;
            
            // Also animate minimap ship
            const minimapShipData = minimapShip.userData;
            minimapShipData.animating = true;
            minimapShipData.startPosition.copy(minimapShip.position);
            minimapShipData.targetPosition.copy(targetPosition);
            minimapShipData.targetPosition.y += minimapPlanets[currentPlanet].size + 5;
            minimapShipData.animationProgress = 0;
        }

        // End the game
        function endGame(success) {
            gameActive = false;
            
            const gameOverDiv = document.getElementById('gameOver');
            const resultsDiv = document.getElementById('results');
            
            gameOverDiv.style.display = 'block';
            
            if (success) {
                document.querySelector('#gameOver h2').textContent = 'Mission Complete!';
                
                // Calculate fuel usage
                const fuelUsed = START_FUEL - currentFuel;
                document.getElementById('playerFuel').textContent = fuelUsed;
                document.getElementById('optimalFuel').textContent = optimalPath.fuel;
                
                // Calculate efficiency percentage
                const efficiency = Math.round((optimalPath.fuel / fuelUsed) * 100);
                document.getElementById('efficiency').textContent = `${efficiency}%`;
                
                // Add information about the optimal path
                const optimalPathInfo = document.createElement('p');
                optimalPathInfo.textContent = `Optimal path: ${optimalPath.path.join(' â†’ ')}`;
                resultsDiv.appendChild(optimalPathInfo);
            } else {
                document.querySelector('#gameOver h2').textContent = 'Mission Failed!';
                
                let failureReason;
                if (currentFuel <= 0) {
                    failureReason = 'You ran out of fuel!';
                } else {
                    failureReason = 'No valid paths remaining to complete the mission!';
                }
                
                const reasonElement = document.createElement('p');
                reasonElement.textContent = failureReason;
                resultsDiv.appendChild(reasonElement);
            }
        }

        // Reset game
        function resetGame() {
            // Clear all trails
            for (const trail of shipTrails) {
                scene.remove(trail);
            }
            shipTrails = [];
            
            for (const trail of minimapTrails) {
                minimapScene.remove(trail);
            }
            minimapTrails = [];
            
            // Reset game variables
            currentFuel = START_FUEL;
            currentPlanet = 'Start Base';
            visitedPlanets = new Set();
            usedPaths = new Set();
            gameActive = true;
            travelHistory = [];
            
            // Reset UI
            document.getElementById('fuelDisplay').textContent = `Fuel Remaining: ${currentFuel}`;
            document.getElementById('currentPosition').textContent = `Current: ${currentPlanet}`;
            document.getElementById('visitedPlanets').textContent = `Planets Visited: 0/${TOTAL_PLANETS}`;
            document.getElementById('gameOver').style.display = 'none';
            
            // Reset ship position
            playerShip.position.copy(planets['Start Base'].position);
            playerShip.position.y += 15;
            
            // Reset minimap ship position
            minimapShip.position.copy(planets['Start Base'].position);
            minimapShip.position.y += 15;
            
            // Reset ship rotation
            playerShip.rotation.set(0, 0, 0);
            minimapShip.rotation.set(0, 0, 0);
            
            // Update path options
            updatePathOptions();
        }

        // Update camera position to follow the ship
        function updateCameraPosition() {
            if (!playerShip) return; // Guard clause if playerShip is not yet defined
            
            // Create a rotated offset based on ship's orientation
            const rotatedOffset = cameraOffset.clone();
            rotatedOffset.applyQuaternion(playerShip.quaternion);
            
            // Position camera relative to ship
            camera.position.copy(playerShip.position).add(rotatedOffset);
            
            // Calculate target position (slightly ahead of ship)
            cameraTarget.copy(playerShip.position);
            const forward = new THREE.Vector3(1, 0, 0).applyQuaternion(playerShip.quaternion);
            cameraTarget.add(forward.multiplyScalar(20));
            
            // Look at the target
            camera.lookAt(cameraTarget);
        }

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            
            // Update ship animation if in progress
            if (playerShip.userData.animating) {
                const shipData = playerShip.userData;
                shipData.animationProgress += 0.01;
                
                if (shipData.animationProgress >= 1) {
                    // Animation complete
                    shipData.animating = false;
                    playerShip.position.copy(shipData.targetPosition);
                } else {
                    // Interpolate position
                    playerShip.position.lerpVectors(
                        shipData.startPosition,
                        shipData.targetPosition,
                        shipData.animationProgress
                    );
                    
                    // Calculate direction for ship to face
                    const direction = new THREE.Vector3().subVectors(
                        shipData.targetPosition,
                        shipData.startPosition
                    ).normalize();
                    
                    // Orient ship to face direction of travel
                    const targetQuaternion = new THREE.Quaternion().setFromUnitVectors(
                        new THREE.Vector3(1, 0, 0), // Ship's forward direction is along x-axis
                        direction
                    );
                    
                    playerShip.quaternion.slerp(targetQuaternion, 0.1);
                }
                
                // Update camera to follow ship in third-person view
                updateCameraPosition();
            }
            
            // Update minimap ship animation
            if (minimapShip.userData.animating) {
                const shipData = minimapShip.userData;
                shipData.animationProgress += 0.01;
                
                if (shipData.animationProgress >= 1) {
                    // Animation complete
                    shipData.animating = false;
                    minimapShip.position.copy(shipData.targetPosition);
                } else {
                    // Interpolate position
                    minimapShip.position.lerpVectors(
                        shipData.startPosition,
                        shipData.targetPosition,
                        shipData.animationProgress
                    );
                    
                    // Calculate direction for ship to face
                    const direction = new THREE.Vector3().subVectors(
                        shipData.targetPosition,
                        shipData.startPosition
                    ).normalize();
                    
                    // Orient ship to face direction of travel
                    const targetQuaternion = new THREE.Quaternion().setFromUnitVectors(
                        new THREE.Vector3(1, 0, 0), // Ship's forward direction is along x-axis
                        direction
                    );
                    
                    minimapShip.quaternion.slerp(targetQuaternion, 0.1);
                }
            }
            
            // Rotate planets gently
            for (const planetName in planets) {
                const planetObj = planets[planetName].object;
                planetObj.rotation.y += 0.001;
            }
            
            // Handle window resizing
            if (renderer.domElement.width !== window.innerWidth || 
                renderer.domElement.height !== window.innerHeight) {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            }
            
            // Render main scene
            renderer.render(scene, camera);
            
            // Render minimap
            minimapRenderer.render(minimapScene, minimapCamera);
        }

        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Add event listeners for buttons
        document.getElementById('restartButton').addEventListener('click', resetGame);
        document.getElementById('undoLastMove').addEventListener('click', undoLastMove);
        document.getElementById('restartGame').addEventListener('click', resetGame);

        // Initialize the game
        initializeGame();
    </script>
</body>
</html>
