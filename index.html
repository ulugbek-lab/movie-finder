<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cosmic Courier: The Route Challenge</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 0;
            background-color: #121212;
            color: #e0e0e0;
            overflow-x: hidden;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }
        
        header {
            text-align: center;
            padding: 20px 0;
            background-color: #1e1e1e;
            border-bottom: 3px solid #7b3ff7;
            margin-bottom: 20px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
            position: relative;
            overflow: hidden;
        }
        
        header::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(45deg, #7b3ff7, #3f51b5);
            opacity: 0.1;
            z-index: 0;
        }
        
        h1 {
            color: #7b3ff7;
            text-shadow: 0 0 15px rgba(123, 63, 247, 0.8);
            margin: 0;
            font-size: 2.8em;
            position: relative;
            z-index: 1;
        }
        
        .game-description {
            background-color: #1e1e1e;
            padding: 20px;
            border-radius: 15px;
            margin-bottom: 25px;
            border-left: 4px solid #7b3ff7;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
            font-size: 1.1em;
            line-height: 1.5;
        }
        
        .game-area {
            display: flex;
            flex-direction: column;
            gap: 25px;
        }
        
        .game-map {
            flex: 1;
            min-width: 300px;
            background-color: #1e1e1e;
            border-radius: 15px;
            padding: 20px;
            position: relative;
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.4);
            overflow: hidden;
        }
        
        .map-container {
            position: relative;
            width: 100%;
            height: 600px; /* Increased height */
            background: radial-gradient(circle at center, #151530, #0c0c1d);
            border-radius: 12px;
            overflow: hidden;
            box-shadow: inset 0 0 40px rgba(0, 0, 0, 0.5);
            perspective: 1000px; /* For 3D effect */
            transform-style: preserve-3d;
            transition: transform 0.5s ease;
        }
        
        .game-controls {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 15px;
            background-color: #1e1e1e;
            border-radius: 15px;
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.4);
        }
        
        .fuel-display {
            display: flex;
            align-items: center;
            background-color: #2a2a40;
            padding: 12px 15px;
            border-radius: 10px;
            box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.3);
            margin-right: 15px;
        }
        
        .fuel-icon {
            margin-right: 15px;
            color: #f7b63f;
            font-size: 28px;
            text-shadow: 0 0 10px rgba(247, 182, 63, 0.8);
        }
        
        .game-info {
            display: flex;
            align-items: center;
            gap: 15px;
        }
        
        .route-display {
            background-color: #2a2a40;
            padding: 15px;
            border-radius: 10px;
            box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.3);
            flex-grow: 1;
            min-height: 60px;
            max-height: 60px;
            overflow-x: auto;
            white-space: nowrap;
            margin-right: 15px;
        }
        
        .route-item {
            display: inline-block;
            background-color: #3e3e5e;
            padding: 8px 14px;
            border-radius: 8px;
            margin-right: 8px;
            box-shadow: 0 3px 8px rgba(0, 0, 0, 0.2);
            animation: addItem 0.3s;
        }
        
        .route-arrow {
            margin: 0 8px;
            color: #7b3ff7;
            font-weight: bold;
            display: inline-block;
        }
        
        .button {
            background: linear-gradient(45deg, #7b3ff7, #6a2ee6);
            color: white;
            border: none;
            padding: 12px 20px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
            font-weight: bold;
            transition: all 0.3s;
            margin-right: 12px;
            box-shadow: 0 4px 10px rgba(123, 63, 247, 0.3);
        }
        
        .button:hover {
            background: linear-gradient(45deg, #8a52ff, #7b3ff7);
            transform: translateY(-3px);
            box-shadow: 0 7px 15px rgba(123, 63, 247, 0.4);
        }
        
        .button:active {
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(123, 63, 247, 0.4);
        }
        
        .button.secondary {
            background: linear-gradient(45deg, #444, #333);
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
        }
        
        .button.secondary:hover {
            background: linear-gradient(45deg, #555, #444);
            box-shadow: 0 7px 15px rgba(0, 0, 0, 0.3);
        }
        
        .results {
            background-color: #1e1e1e;
            border-radius: 15px;
            padding: 20px;
            margin-top: 25px;
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.4);
        }
        
        .results h2 {
            color: #7b3ff7;
            border-bottom: 2px solid #2e2e2e;
            padding-bottom: 8px;
        }
        
        .results-content {
            display: none;
            animation: fadeIn 0.7s;
        }
        
        /* 3D Planet styling */
        .planet {
            position: absolute;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            box-shadow: 0 0 30px rgba(123, 63, 247, 0.6), inset 0 0 15px rgba(255, 255, 255, 0.4);
            cursor: pointer;
            z-index: 10;
            transform-style: preserve-3d;
            transition: all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }
        
        .planet:hover {
            transform: scale(1.2) translateZ(20px);
            box-shadow: 0 0 40px rgba(123, 63, 247, 0.8), inset 0 0 20px rgba(255, 255, 255, 0.6);
        }
        
        .planet.selected {
            box-shadow: 0 0 40px rgba(255, 215, 0, 0.8), inset 0 0 20px rgba(255, 255, 255, 0.6);
            border: 2px solid gold;
        }
        
        .planet-name {
            position: absolute;
            bottom: -28px;
            background: linear-gradient(to right, rgba(30, 30, 30, 0.9), rgba(46, 46, 46, 0.9));
            padding: 4px 10px;
            border-radius: 12px;
            font-size: 13px;
            white-space: nowrap;
            box-shadow: 0 3px 10px rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(123, 63, 247, 0.3);
            transform: translateZ(10px);
        }
        
        .planet-ring {
            position: absolute;
            box-shadow: 0 0 10px rgba(255, 255, 255, 0.3);
            transform-style: preserve-3d;
            transition: all 0.3s;
            animation: rotateRing 10s linear infinite;
        }
        
        @keyframes rotateRing {
            from { transform: rotateX(75deg) rotateZ(0deg); }
            to { transform: rotateX(75deg) rotateZ(360deg); }
        }
        
        .path {
            position: absolute;
            background: linear-gradient(to right, rgba(123, 63, 247, 0.05), rgba(255, 255, 255, 0.2));
            transform-origin: 0 50%;
            pointer-events: none;
            z-index: 1;
            border-radius: 2px;
            box-shadow: 0 0 8px rgba(123, 63, 247, 0.2);
            transform-style: preserve-3d;
        }
        
        .selected-path {
            position: absolute;
            background: linear-gradient(to right, rgba(123, 63, 247, 0.7), rgba(123, 63, 247, 0.5));
            transform-origin: 0 50%;
            pointer-events: none;
            z-index: 2;
            box-shadow: 0 0 15px rgba(123, 63, 247, 0.9);
            border-radius: 3px;
            animation: pulsePath 2s infinite alternate;
            transform-style: preserve-3d;
        }
        
        /* Space dust particle effect */
        .space-dust {
            position: absolute;
            width: 2px;
            height: 2px;
            background-color: rgba(255, 255, 255, 0.5);
            border-radius: 50%;
            pointer-events: none;
            animation: float 15s linear infinite;
        }
        
        .star {
            position: absolute;
            background-color: white;
            border-radius: 50%;
            opacity: 0.8;
            pointer-events: none;
            animation: twinkle 4s ease-in-out infinite alternate;
        }
        
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            z-index: 100;
            align-items: center;
            justify-content: center;
            backdrop-filter: blur(5px);
        }
        
        .modal-content {
            background-color: #1e1e2e;
            padding: 25px;
            border-radius: 15px;
            max-width: 550px;
            width: 90%;
            position: relative;
            animation: zoomIn 0.4s;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5), 0 0 0 1px rgba(123, 63, 247, 0.3);
            border: 1px solid rgba(123, 63, 247, 0.3);
        }
        
        .close-modal {
            position: absolute;
            top: 15px;
            right: 15px;
            font-size: 28px;
            cursor: pointer;
            color: #777;
            transition: all 0.2s;
        }
        
        .close-modal:hover {
            color: #fff;
            transform: rotate(90deg);
        }
        
        .event-popup {
            position: absolute;
            background: linear-gradient(to bottom, #2a2a50, #1e1e3e);
            border: 2px solid #7b3ff7;
            border-radius: 15px;
            padding: 20px;
            max-width: 350px;
            box-shadow: 0 0 30px rgba(123, 63, 247, 0.7);
            z-index: 50;
            animation: popIn 0.4s;
            display: none;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }
        
        .event-popup h3 {
            color: #ff9800;
            margin-top: 0;
            text-shadow: 0 0 10px rgba(255, 152, 0, 0.5);
        }
        
        .event-visual {
            position: absolute;
            pointer-events: none;
            z-index: 40;
        }
        
        .asteroid {
            width: 15px;
            height: 15px;
            background-color: #aaa;
            border-radius: 50%;
            box-shadow: inset -2px -2px 3px rgba(0,0,0,0.5), 0 0 10px rgba(255,255,255,0.5);
            position: absolute;
            z-index: 30;
        }
        
        .alien-ship {
            width: 30px;
            height: 15px;
            background-color: #ff4081;
            border-radius: 50%;
            box-shadow: 0 0 15px #ff4081;
            position: absolute;
            z-index: 30;
        }
        
        .wormhole {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background: conic-gradient(from 0deg, #7b3ff7, #3f51b5, #7b3ff7);
            box-shadow: 0 0 30px #7b3ff7;
            position: absolute;
            z-index: 25;
            animation: rotate 3s linear infinite;
        }
        
        .solar-flare {
            width: 100px;
            height: 100px;
            background: radial-gradient(circle, #f7b63f, transparent);
            position: absolute;
            z-index: 25;
            animation: pulse 2s infinite alternate;
        }
        
        .pirate-ship {
            width: 40px;
            height: 20px;
            background-color: #555;
            border-radius: 5px;
            position: absolute;
            z-index: 30;
            box-shadow: 0 0 15px rgba(255,255,255,0.3);
        }
        
        .pirate-ship::before {
            content: '☠️';
            position: absolute;
            top: -15px;
            left: 10px;
            font-size: 20px;
        }
        
        /* Control panel for 3D view */
        .view-controls {
            position: absolute;
            bottom: 20px;
            right: 20px;
            z-index: 20;
            display: flex;
            gap: 10px;
        }
        
        .view-control-btn {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: rgba(30, 30, 50, 0.8);
            border: 2px solid #7b3ff7;
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-size: 20px;
            box-shadow: 0 0 15px rgba(123, 63, 247, 0.4);
            transition: all 0.2s;
        }
        
        .view-control-btn:hover {
            transform: scale(1.1);
            box-shadow: 0 0 20px rgba(123, 63, 247, 0.7);
        }
        
        .help-tip {
            background-color: #2e2e4e;
            border-radius: 10px;
            padding: 15px;
            margin-top: 15px;
            box-shadow: inset 0 0 10px rgba(0,0,0,0.3);
            border-left: 3px solid #ff9800;
        }
        
        .help-tip h4 {
            color: #ff9800;
            margin-top: 0;
        }
        
        /* Notifications */
        .notification {
            position: fixed;
            top: 20px;
            right: 20px;
            background: linear-gradient(to bottom, #2a2a50, #1e1e3e);
            border-left: 4px solid #7b3ff7;
            padding: 15px 20px;
            border-radius: 8px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
            z-index: 1000;
            transform: translateX(120%);
            transition: transform 0.3s ease-out;
            max-width: 300px;
        }
        
        .notification.show {
            transform: translateX(0);
        }
        
        /* Animations */
        @keyframes pulsePath {
            from { opacity: 0.7; }
            to { opacity: 1; }
        }
        
        @keyframes addItem {
            from { transform: translateY(-10px); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }
        
        @keyframes pulse {
            from { opacity: 0.5; transform: scale(0.8); }
            to { opacity: 1; transform: scale(1.2); }
        }
        
        @keyframes rotate {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }
        
        @keyframes float {
            from { transform: translate3d(0, 0, 0); }
            to { transform: translate3d(-100px, 100px, 100px); }
        }
        
        @keyframes twinkle {
            0% { opacity: 0.3; }
            50% { opacity: 0.8; }
            100% { opacity: 0.3; }
        }
        
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        
        @keyframes zoomIn {
            from { transform: scale(0.8); opacity: 0; }
            to { transform: scale(1); opacity: 1; }
        }
        
        @keyframes popIn {
            0% { transform: translate(-50%, -50%) scale(0.5); opacity: 0; }
            70% { transform: translate(-50%, -50%) scale(1.1); opacity: 1; }
            100% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
        }
        
        @media (max-width: 768px) {
            .game-area {
                flex-direction: column;
            }
            
            .map-container {
                height: 400px;
            }
            
            .game-controls {
                flex-direction: column;
                gap: 15px;
            }
            
            .game-info {
                width: 100%;
            }
            
            .route-display {
                width: 100%;
                margin-right: 0;
                margin-bottom: 10px;
            }
        }
    </style>
</head>
<body>
    <header>
        <h1>Cosmic Courier: The Route Challenge</h1>
    </header>
    
    <div class="container">
        <div class="game-description">
            <p>You are a Cosmic Courier tasked with delivering vital packages to different planets in the galaxy. Visit each planet once and return to your starting point while using the least amount of fuel! Watch out for space anomalies that may affect your journey!</p>
            <div class="help-tip">
                <h4>Quick Guide:</h4>
                <p>1. Click directly on planets in the space map to select your route</p>
                <p>2. Visit each planet exactly once and return to your starting point</p>
                <p>3. Use the least amount of fuel possible to complete your route</p>
                <p>4. Use the view controls to rotate and zoom the 3D galaxy map</p>
            </div>
        </div>
        
        <div class="game-area">
            <div class="game-map">
                <div class="map-container" id="map">
                    <!-- Planets and paths will be generated here -->
                    <div class="view-controls">
                        <div class="view-control-btn" id="rotate-left">⟲</div>
                        <div class="view-control-btn" id="rotate-right">⟳</div>
                        <div class="view-control-btn" id="reset-view">⊕</div>
                    </div>
                </div>
            </div>
            
            <div class="game-controls">
                <div class="game-info">
                    <div class="fuel-display">
                        <div class="fuel-icon">⚡</div>
                        <div>Fuel: <span id="fuel-counter">0</span> units</div>
                    </div>
                    
                    <div class="route-display" id="route-display"></div>
                </div>
                
                <div>
                    <button class="button" id="validate-route">Complete Mission</button>
                    <button class="button secondary" id="reset-route">Reset Route</button>
                    <button class="button secondary" id="show-instructions">How to Play</button>
                </div>
            </div>
        </div>
        
        <div class="results" id="results">
            <h2>Mission Results</h2>
            <div class="results-content" id="results-content"></div>
        </div>
    </div>
    
    <div class="modal" id="instructions-modal">
        <div class="modal-content">
            <span class="close-modal" id="close-instructions">&times;</span>
            <h2>Mission Briefing</h2>
            <p>Welcome, Cosmic Courier! Your mission is to deliver packages to all planets in the galaxy while using the least amount of fuel possible.</p>
            
            <h3>How to Play:</h3>
            <ol>
                <li>The planets are arranged in a 3D galaxy pattern</li>
                <li>Click directly on planets in the order you wish to visit them</li>
                <li>Each planet must be visited exactly once</li>
                <li>You must return to your starting planet at the end</li>
                <li>Use the view controls to rotate and explore the 3D galaxy</li>
                <li>The goal is to complete your route with minimal fuel consumption</li>
                <li>Watch out for space anomalies that will appear during your journey!</li>
            </ol>
            
            <h3>Tips:</h3>
            <ul>
                <li>The fuel required for each path is shown as a glowing trail between planets</li>
                <li>Plan carefully - sometimes the longest-looking route may use less fuel</li>
                <li>Space events can help or hurt your mission - adapt your strategy accordingly</li>
                <li>Rotate the galaxy view to find optimal routes that might be hidden</li>
            </ul>
            
            <button class="button" id="start-mission">Begin Mission</button>
        </div>
    </div>
    
    <div class="modal" id="results-modal">
        <div class="modal-content">
            <span class="close-modal" id="close-results">&times;</span>
            <h2>Mission Complete!</h2>
            <div id="modal-results-content"></div>
            <button class="button" id="try-again">Try Again</button>
        </div>
    </div>
    
    <div class="event-popup" id="event-popup">
        <h3 id="event-title">Space Event!</h3>
        <p id="event-description">Description of the event goes here.</p>
        <button class="button" id="event-ok">OK</button>
    </div>
    
    <div class="notification" id="notification"></div>
    
    <script>
        // Game state
        const gameState = {
            planets: [],
            paths: [],
            currentRoute: [],
            startPlanet: null,
            selectedPaths: [],
            optimalRoute: null,
            activeEvent: null,
            viewRotation: { x: 0, y: 0 }
        };
        
        // Planet colors with more vibrant, cosmic colors
        const planetColors = [
            '#f44336', '#e91e63', '#9c27b0', '#673ab7', 
            '#3f51b5', '#2196f3', '#03a9f4', '#00bcd4', 
            '#009688', '#4caf50', '#8bc34a', '#cddc39', 
            '#ffeb3b', '#ffc107', '#ff9800', '#ff5722'
        ];
        
        // Planet names - more exotic and cosmic
        const planetNames = [
            'Nebulon', 'Asteria', 'Kronos', 'Zephyr', 
            'Solaris', 'Lunara', 'Polaris', 'Thalassa', 
            'Calypso', 'Hyperion', 'Orion', 'Celeste', 
            'Phoenix', 'Atlas', 'Nova', 'Elysium',
            'Zenith', 'Oberon', 'Triton', 'Pandora'
        ];
        
        // Space events
        const spaceEvents = [
            {
                title: "Solar Flare!",
                description: "A sudden solar flare has reduced your fuel efficiency. The next path you select will cost 20% more fuel.",
                effect: "increaseCost",
                value: 0.2,
                visual: "solarFlare"
            },
            {
                title: "Gravitational Slingshot!",
                description: "You've discovered a gravitational slingshot opportunity! The next path you select will use 30% less fuel.",
                effect: "decreaseCost",
                value: 0.3,
                visual: "slingshot"
            },
            {
                title: "Asteroid Field!",
                description: "An asteroid field has appeared! You'll need to navigate carefully and may need to adjust your route.",
                effect: "blockPath",
                value: null,
                visual: "asteroids"
            },
            {
                title: "Alien Attack!",
                description: "Your ship is under attack by alien raiders! You'll need to take evasive action, increasing your next path's fuel cost by 50%.",
                effect: "increaseCost",
                value: 0.5,
                visual: "alienAttack"
            },
            {
                title: "Wormhole Discovered!",
                description: "You've found a stable wormhole! You can now instantly travel to any planet with no fuel cost for your next move.",
                effect: "freePath",
                value: null,
                visual: "wormhole"
            },
            {
                title: "Space Pirates!",
                description: "Space pirates are demanding a toll! Pay 10 units of fuel or find another route.",
                effect: "fixedCost",
                value: 10,
                visual: "pirates"
            }
        ];
        
        // DOM elements
        const mapContainer = document.getElementById('map');
        const routeDisplay = document.getElementById('route-display');
        const fuelCounter = document.getElementById('fuel-counter');
        const validateButton = document.getElementById('validate-route');
        const resetButton = document.getElementById('reset-route');
        const instructionsButton = document.getElementById('show-instructions');
        const instructionsModal = document.getElementById('instructions-modal');
        const resultsModal = document.getElementById('results-modal');
        const eventPopup = document.getElementById('event-popup');
        const closeInstructions = document.getElementById('close-instructions');
        const closeResults = document.getElementById('close-results');
        const startMissionButton = document.getElementById('start-mission');
        const tryAgainButton = document.getElementById('try-again');
        const eventOkButton = document.getElementById('event-ok');
        const resultsContainer = document.getElementById('results');
        const resultsContent = document.getElementById('results-content');
        const modalResultsContent = document.getElementById('modal-results-content');
        const notification = document.getElementById('notification');
        
        // View control buttons
        const rotateLeftBtn = document.getElementById('rotate-left');
        const rotateRightBtn = document.getElementById('rotate-right');
        const resetViewBtn = document.getElementById('reset-view');
        
        // Initialize the game
        function initGame() {
            // Generate background stars and space dust
            generateStarfield();
            
            // Set up game
            setupGame();
            
            // Add event listeners
            setupEventListeners();
            
            // Show instructions on first load
            instructionsModal.style.display = 'flex';
        }
        
        // Generate background stars and space dust effect
        function generateStarfield() {
            // Generate more stars for a richer background
            const starCount = 200;
            for (let i = 0; i < starCount; i++) {
                const star = document.createElement('div');
                star.className = 'star';
                
                // Random size between 1 and 3 pixels
                const size = Math.random() * 2 + 1;
                star.style.width = `${size}px`;
                star.style.height = `${size}px`;
                
                // Random position in 3D space
                star.style.left = `${Math.random() * 100}%`;
                star.style.top = `${Math.random() * 100}%`;
                star.style.transform = `translateZ(${Math.random() * 50 - 25}px)`;
                
                // Random opacity and twinkle animation
                star.style.opacity = Math.random() * 0.8 + 0.2;
                star.style.animationDelay = `${Math.random() * 4}s`;
                
                mapContainer.appendChild(star);
            }
            
            // Add space dust particles for 3D depth effect
            const dustCount = 50;
            for (let i = 0; i < dustCount; i++) {
                const dust = document.createElement('div');
                dust.className = 'space-dust';
                
                // Random position
                dust.style.left = `${Math.random() * 100}%`;
                dust.style.top = `${Math.random() * 100}%`;
                dust.style.transform = `translateZ(${Math.random() * 100 - 50}px)`;
                
                // Random opacity
                dust.style.opacity = Math.random() * 0.3 + 0.1;
                
                // Random animation delay
                dust.style.animationDelay = `${Math.random() * 15}s`;
                dust.style.animationDuration = `${15 + Math.random() * 10}s`;
                
                mapContainer.appendChild(dust);
            }
        }
        
        // Setup the game
        function setupGame() {
            // Clear previous game
            clearGame();
            
            // Generate planets in 3D arrangement
            generatePlanets(7); // 7 planets (6 + 1 center)
            
            // Generate paths between planets
            generatePaths();
            
            // Choose a random planet as the starting point
            gameState.startPlanet = gameState.planets[Math.floor(Math.random() * gameState.planets.length)];
            gameState.startPlanet.element.classList.add('selected');
            
            // Add the start planet to the route
            addToRoute(gameState.startPlanet);
            
            // Generate an approximate optimal route for scoring
            generateOptimalRoute();
            
            // Show notification about starting planet
            showNotification(`Starting from ${gameState.startPlanet.name}. Select your next destination!`);
        }
        
        // Clear the current game
        function clearGame() {
            // Clear planets and paths
            gameState.planets = [];
            gameState.paths = [];
            gameState.currentRoute = [];
            gameState.selectedPaths = [];
            gameState.startPlanet = null;
            gameState.activeEvent = null;
            
            // Clear UI elements
            mapContainer.innerHTML = '';
            generateStarfield(); // Regenerate stars
            
            // Add view controls back
            const viewControls = document.createElement('div');
            viewControls.className = 'view-controls';
            viewControls.innerHTML = `
                <div class="view-control-btn" id="rotate-left">⟲</div>
                <div class="view-control-btn" id="rotate-right">⟳</div>
                <div class="view-control-btn" id="reset-view">⊕</div>
            `;
            mapContainer.appendChild(viewControls);
            
            // Reset rotation
            gameState.viewRotation = { x: 0, y: 0 };
            updateMapView();
            
            // Reset counters
            fuelCounter.textContent = '0';
            
            // Clear route display
            routeDisplay.innerHTML = '';
            
            // Hide results
            resultsContainer.querySelector('.results-content').style.display = 'none';
        }
        
        // Generate planets in a 3D arrangement
        function generatePlanets(count) {
            const mapWidth = mapContainer.offsetWidth;
            const mapHeight = mapContainer.offsetHeight;
            const centerX = mapWidth / 2;
            const centerY = mapHeight / 2;
            const radius = Math.min(mapWidth, mapHeight) * 0.35; // Size of the arrangement
            
            for (let i = 0; i < count; i++) {
                let x, y, z;
                let size = 30 + Math.random() * 10; // Base planet size
                
                if (i === 0) {
                    // Center planet
                    x = centerX;
                    y = centerY;
                    z = 0;
                    size = 40; // Make center planet larger
                } else {
                    // Calculate position in 3D space
                    // For a more interesting 3D arrangement, use spherical coordinates
                    const phi = Math.acos(-1 + (2 * (i - 1)) / (count - 2)); // Polar angle
                    const theta = Math.sqrt(count - 1) * Math.PI * (i - 1) / (count - 2); // Azimuthal angle
                    
                    x = centerX + radius * Math.sin(phi) * Math.cos(theta);
                    y = centerY + radius * Math.sin(phi) * Math.sin(theta);
                    z = radius * 0.5 * Math.cos(phi); // Reduced z-depth for better visibility
                }
                
                // Create a new planet
                const planet = {
                    id: i,
                    name: planetNames[i % planetNames.length],
                    color: planetColors[i % planetColors.length],
                    x: x,
                    y: y,
                    z: z,
                    size: size
                };
                
                // Create the planet element
                const planetElement = document.createElement('div');
                planetElement.className = 'planet';
                planetElement.style.left = `${planet.x - planet.size/2}px`;
                planetElement.style.top = `${planet.y - planet.size/2}px`;
                planetElement.style.width = `${planet.size}px`;
                planetElement.style.height = `${planet.size}px`;
                planetElement.style.backgroundColor = planet.color;
                planetElement.style.boxShadow = `0 0 20px ${planet.color}80, inset 0 0 15px rgba(255,255,255,0.8)`;
                planetElement.style.transform = `translateZ(${planet.z}px)`;
                planetElement.dataset.id = planet.id;
                
                // Add planet name
                const nameElement = document.createElement('div');
                nameElement.className = 'planet-name';
                nameElement.textContent = planet.name;
                planetElement.appendChild(nameElement);
                
                // Add planet to the map
                mapContainer.appendChild(planetElement);
                
                // Add a planet ring for visual effect (more likely for outer planets)
                if (i !== 0 && Math.random() > 0.4) {
                    const ringElement = document.createElement('div');
                    ringElement.className = 'planet-ring';
                    ringElement.style.width = `${planet.size * 1.8}px`;
                    ringElement.style.height = `${planet.size * 0.3}px`;
                    ringElement.style.left = `${-planet.size * 0.4}px`;
                    ringElement.style.top = `${planet.size/2 - planet.size * 0.15}px`;
                    ringElement.style.borderRadius = '50%';
                    ringElement.style.backgroundColor = `${planet.color}40`; // Semi-transparent ring matching planet color
                    ringElement.style.boxShadow = `0 0 10px ${planet.color}60`;
                    
                    // Add the ring to the planet
                    planetElement.appendChild(ringElement);
                }
                
                // Add click event to the planet
                planetElement.addEventListener('click', () => {
                    selectPlanet(planet);
                });
                
                // Store the element reference
                planet.element = planetElement;
                
                // Add to game state
                gameState.planets.push(planet);
            }
        }
        
        // Generate paths between planets
        function generatePaths() {
            const planets = gameState.planets;
            
            // Create paths between all planets
            for (let i = 0; i < planets.length; i++) {
                for (let j = i + 1; j < planets.length; j++) {
                    const planetA = planets[i];
                    const planetB = planets[j];
                    
                    // Calculate 3D distance
                    const dx = planetB.x - planetA.x;
                    const dy = planetB.y - planetA.y;
                    const dz = planetB.z - planetA.z;
                    const distance = Math.sqrt(dx * dx + dy * dy + dz * dz);
                    
                    // Calculate fuel cost (3D distance-based with some randomness)
                    const baseCost = Math.round(distance / 10);
                    const randomFactor = 0.7 + Math.random() * 0.6; // 0.7 to 1.3
                    const cost = Math.max(1, Math.round(baseCost * randomFactor));
                    
                    // Calculate angle for path orientation
                    const angle = Math.atan2(dy, dx) * (180 / Math.PI);
                    
                    // Create path object
                    const path = {
                        from: planetA,
                        to: planetB,
                        cost: cost,
                        distance: distance,
                        angle: angle,
                        dz: dz // Store the z-difference for 3D effect
                    };
                    
                    // Create path element
                    const pathElement = document.createElement('div');
                    pathElement.className = 'path';
                    pathElement.style.width = `${distance}px`;
                    pathElement.style.height = '2px';
                    pathElement.style.left = `${planetA.x}px`;
                    pathElement.style.top = `${planetA.y}px`;
                    pathElement.style.transform = `rotate(${angle}deg) scaleY(${1 + Math.abs(dz) / 100})`;
                    
                    // Make path width proportional to cost
                    pathElement.style.opacity = 0.2 + (cost / 30) * 0.5; // Higher cost = more visible
                    
                    // Show cost on hover
                    pathElement.title = `Fuel cost: ${cost} units`;
                    
                    // Add path to the map
                    mapContainer.appendChild(pathElement);
                    
                    // Store the element reference
                    path.element = pathElement;
                    
                    // Add to game state
                    gameState.paths.push(path);
                }
            }
        }
        
        // Select a planet
        function selectPlanet(planet) {
            // Skip if this is already the last planet in our route
            if (gameState.currentRoute.length > 0 && 
                gameState.currentRoute[gameState.currentRoute.length - 1] === planet) {
                return;
            }
            
            // Skip if this planet is already in our route (unless it's the start planet and we're completing the circle)
            const isInRoute = gameState.currentRoute.includes(planet);
            const isStartPlanet = planet === gameState.startPlanet;
            const isLastStep = gameState.currentRoute.length === gameState.planets.length;
            
            if (isInRoute && !(isStartPlanet && isLastStep)) {
                showNotification(`You've already visited ${planet.name}!`);
                return;
            }
            
            // Get the last planet in our route
            const lastPlanet = gameState.currentRoute[gameState.currentRoute.length - 1];
            
            // Find the path between the last planet and the selected one
            const path = findPath(lastPlanet, planet);
            
            if (path) {
                // Create a visual selected path
                const selectedPath = document.createElement('div');
                selectedPath.className = 'selected-path';
                selectedPath.style.width = `${path.distance}px`;
                selectedPath.style.height = '4px';
                
                // Position based on which direction the path goes
                if (path.from === lastPlanet) {
                    selectedPath.style.left = `${path.from.x}px`;
                    selectedPath.style.top = `${path.from.y}px`;
                    selectedPath.style.transform = `rotate(${path.angle}deg) scaleY(${1 + Math.abs(path.dz) / 100})`;
                } else {
                    selectedPath.style.left = `${path.to.x}px`;
                    selectedPath.style.top = `${path.to.y}px`;
                    // Add 180 degrees to reverse the direction
                    selectedPath.style.transform = `rotate(${path.angle + 180}deg) scaleY(${1 + Math.abs(path.dz) / 100})`;
                }
                
                // Add to map
                mapContainer.appendChild(selectedPath);
                gameState.selectedPaths.push(selectedPath);
                
                // Apply any active events
                let effectiveCost = path.cost;
                if (gameState.activeEvent) {
                    switch(gameState.activeEvent.effect) {
                        case 'increaseCost':
                            effectiveCost = Math.round(path.cost * (1 + gameState.activeEvent.value));
                            showNotification(`Event effect: Fuel cost increased to ${effectiveCost} units!`);
                            break;
                        case 'decreaseCost':
                            effectiveCost = Math.round(path.cost * (1 - gameState.activeEvent.value));
                            showNotification(`Event effect: Fuel cost reduced to ${effectiveCost} units!`);
                            break;
                        case 'freePath':
                            effectiveCost = 0;
                            showNotification(`Event effect: Free travel to ${planet.name}!`);
                            break;
                        case 'fixedCost':
                            effectiveCost = gameState.activeEvent.value;
                            showNotification(`Event effect: Fixed fuel cost of ${effectiveCost} units!`);
                            break;
                    }
                    
                    // Clear the active event after it's been applied
                    gameState.activeEvent = null;
                }
                
                // Add to route
                addToRoute(planet, effectiveCost);
                planet.element.classList.add('selected');
                
                // Pulse animation on selected planet
                planet.element.style.animation = 'pulse 1s 1';
                setTimeout(() => {
                    planet.element.style.animation = '';
                }, 1000);
                
                // Trigger random event (20% chance)
                if (Math.random() < 0.2) {
                    triggerRandomEvent();
                }
                
                // Check if all planets have been visited
                if (gameState.currentRoute.length === gameState.planets.length) {
                    // If all planets visited, highlight the starting planet to complete the journey
                    if (gameState.startPlanet) {
                        showNotification(`Visit all planets! Return to ${gameState.startPlanet.name} to complete your mission.`);
                    }
                }
                
                // If we've returned to the start and visited all planets, auto-validate
                if (planet === gameState.startPlanet && gameState.currentRoute.length === gameState.planets.length + 1) {
                    // Short delay before validating to allow user to see the completed route
                    setTimeout(() => {
                        validateRoute();
                    }, 500);
                }
            } else {
                showNotification(`No direct path to ${planet.name} from your current position!`);
            }
        }
        
        // Find path between two planets
        function findPath(planetA, planetB) {
            return gameState.paths.find(path => 
                (path.from === planetA && path.to === planetB) || 
                (path.from === planetB && path.to === planetA)
            );
        }
        
        // Trigger a random space event
        function triggerRandomEvent() {
            const event = spaceEvents[Math.floor(Math.random() * spaceEvents.length)];
            
            // Set event popup content
            document.getElementById('event-title').textContent = event.title;
            document.getElementById('event-description').textContent = event.description;
            
            // Show the popup
            eventPopup.style.display = 'block';
            
            // Create visual effect based on event type
            createEventVisual(event.visual);
            
            // Apply event effect
            applyEventEffect(event);
        }
        
        // Create visual effect for the event
        function createEventVisual(visualType) {
            // Clear any existing visuals
            const existingVisuals = document.querySelectorAll('.event-visual, .asteroid, .alien-ship, .wormhole, .solar-flare, .pirate-ship');
            existingVisuals.forEach(visual => visual.remove());
            
            const mapRect = mapContainer.getBoundingClientRect();
            
            switch(visualType) {
                case 'asteroids':
                    // Create multiple asteroids
                    for (let i = 0; i < 15; i++) {
                        const asteroid = document.createElement('div');
                        asteroid.className = 'asteroid';
                        asteroid.style.left = `${Math.random() * mapRect.width}px`;
                        asteroid.style.top = `${Math.random() * mapRect.height}px`;
                        asteroid.style.transform = `translateZ(${Math.random() * 50}px)`;
                        
                        // Random size
                        const size = 5 + Math.random() * 15;
                        asteroid.style.width = `${size}px`;
                        asteroid.style.height = `${size}px`;
                        
                        // Random movement animation
                        asteroid.style.animation = `fly ${2 + Math.random() * 4}s linear infinite`;
                        asteroid.style.animationDelay = `${Math.random() * 2}s`;
                        
                        mapContainer.appendChild(asteroid);
                        
                        // Remove after 6 seconds
                        setTimeout(() => {
                            if (asteroid.parentNode) {
                                asteroid.parentNode.removeChild(asteroid);
                            }
                        }, 6000);
                    }
                    break;
                    
                case 'alienAttack':
                    // Create alien ships
                    for (let i = 0; i < 3; i++) {
                        const alien = document.createElement('div');
                        alien.className = 'alien-ship';
                        alien.style.left = `${-50 + Math.random() * 30}px`;
                        alien.style.top = `${Math.random() * mapRect.height}px`;
                        alien.style.transform = `translateZ(${Math.random() * 50}px)`;
                        
                        // Animation
                        alien.style.animation = `fly ${3 + Math.random() * 2}s linear infinite`;
                        alien.style.animationDelay = `${Math.random() * 1.5}s`;
                        
                        mapContainer.appendChild(alien);
                        
                        // Remove after 6 seconds
                        setTimeout(() => {
                            if (alien.parentNode) {
                                alien.parentNode.removeChild(alien);
                            }
                        }, 6000);
                    }
                    break;
                    
                case 'wormhole':
                    const wormhole = document.createElement('div');
                    wormhole.className = 'wormhole';
                    
                    // Position in a random location
                    wormhole.style.left = `${Math.random() * (mapRect.width - 60)}px`;
                    wormhole.style.top = `${Math.random() * (mapRect.height - 60)}px`;
                    
                    mapContainer.appendChild(wormhole);
                    
                    // Remove after 6 seconds
                    setTimeout(() => {
                        if (wormhole.parentNode) {
                            wormhole.parentNode.removeChild(wormhole);
                        }
                    }, 6000);
                    break;
                    
                case 'solarFlare':
                    const flare = document.createElement('div');
                    flare.className = 'solar-flare';
                    
                    // Position at the edge
                    flare.style.left = `${-50}px`;
                    flare.style.top = `${-50}px`;
                    
                    mapContainer.appendChild(flare);
                    
                    // Remove after 6 seconds
                    setTimeout(() => {
                        if (flare.parentNode) {
                            flare.parentNode.removeChild(flare);
                        }
                    }, 6000);
                    break;
                    
                case 'pirates':
                    const pirates = document.createElement('div');
                    pirates.className = 'pirate-ship';
                    
                    // Position in a random location
                    pirates.style.left = `${Math.random() * (mapRect.width - 40)}px`;
                    pirates.style.top = `${Math.random() * (mapRect.height - 20)}px`;
                    pirates.style.transform = `translateZ(${Math.random() * 30}px) rotate(${Math.random() * 30 - 15}deg)`;
                    
                    mapContainer.appendChild(pirates);
                    
                    // Remove after 6 seconds
                    setTimeout(() => {
                        if (pirates.parentNode) {
                            pirates.parentNode.removeChild(pirates);
                        }
                    }, 6000);
                    break;
                    
                case 'slingshot':
                    // Create a visual effect for slingshot
                    const slingshot = document.createElement('div');
                    slingshot.className = 'event-visual';
                    slingshot.style.width = '150px';
                    slingshot.style.height = '150px';
                    slingshot.style.borderRadius = '50%';
                    slingshot.style.background = 'radial-gradient(circle, rgba(123, 63, 247, 0.2), transparent)';
                    slingshot.style.animation = 'pulse 1.5s infinite alternate';
                    
                    // Position in center
                    slingshot.style.left = `${mapRect.width/2 - 75}px`;
                    slingshot.style.top = `${mapRect.height/2 - 75}px`;
                    
                    mapContainer.appendChild(slingshot);
                    
                    // Remove after 6 seconds
                    setTimeout(() => {
                        if (slingshot.parentNode) {
                            slingshot.parentNode.removeChild(slingshot);
                        }
                    }, 6000);
                    break;
                
                default:
                    break;
            }
        }
        
        // Apply the effect of the event
        function applyEventEffect(event) {
            // Store the event effect in game state
            gameState.activeEvent = event;
            
            // Effects will be applied when the next path is selected in the selectPlanet function
        }
        
        // Add a planet to the current route
        function addToRoute(planet, cost = 0) {
            gameState.currentRoute.push(planet);
            
            // Update the route display
            updateRouteDisplay();
            
            // Update the fuel counter
            const currentFuel = parseInt(fuelCounter.textContent);
            fuelCounter.textContent = currentFuel + cost;
        }
        
        // Update the route display
        function updateRouteDisplay() {
            routeDisplay.innerHTML = '';
            
            gameState.currentRoute.forEach((planet, index) => {
                const routeItem = document.createElement('div');
                routeItem.className = 'route-item';
                routeItem.textContent = planet.name;
                routeItem.style.backgroundColor = planet.color;
                routeItem.style.color = getContrastColor(planet.color);
                
                routeDisplay.appendChild(routeItem);
                
                // Add arrow between planets
                if (index < gameState.currentRoute.length - 1) {
                    const arrow = document.createElement('span');
                    arrow.className = 'route-arrow';
                    arrow.textContent = '→';
                    routeDisplay.appendChild(arrow);
                }
            });
        }
        
        // Get a contrasting text color for a background color
        function getContrastColor(hexColor) {
            // Convert hex to RGB
            const r = parseInt(hexColor.slice(1, 3), 16);
            const g = parseInt(hexColor.slice(3, 5), 16);
            const b = parseInt(hexColor.slice(5, 7), 16);
            
            // Calculate luminance
            const luminance = (0.299 * r + 0.587 * g + 0.114 * b) / 255;
            
            // Return black or white based on luminance
            return luminance > 0.5 ? '#000000' : '#ffffff';
        }
        
        // Validate the route
        function validateRoute() {
            const isComplete = gameState.currentRoute.length === gameState.planets.length + 1;
            const endsAtStart = gameState.currentRoute[0] === gameState.currentRoute[gameState.currentRoute.length - 1];
            
            // Calculate the total fuel cost
            let totalFuel = parseInt(fuelCounter.textContent);
            
            // Check if the route is valid
            if (gameState.currentRoute.length <= 1) {
                showNotification('You need to visit all planets before completing your mission!');
                return;
            }
            
            if (!isComplete) {
                showNotification(`You need to visit all ${gameState.planets.length} planets before returning to your starting point.`);
                return;
            }
            
            if (!endsAtStart) {
                showNotification(`Your route must end at your starting planet: ${gameState.startPlanet.name}.`);
                return;
            }
            
            // Calculate score based on optimal route
            const optimalFuel = gameState.optimalRoute.cost;
            const efficiency = Math.round((optimalFuel / totalFuel) * 100);
            let rating;
            
            if (efficiency >= 95) {
                rating = 'S+';
            } else if (efficiency >= 90) {
                rating = 'S';
            } else if (efficiency >= 80) {
                rating = 'A';
            } else if (efficiency >= 70) {
                rating = 'B';
            } else if (efficiency >= 60) {
                rating = 'C';
            } else {
                rating = 'D';
            }
            
            // Show results with animated emoji
            let emoji = '';
            if (rating === 'S+' || rating === 'S') {
                emoji = '🌟';
            } else if (rating === 'A') {
                emoji = '✨';
            } else if (rating === 'B') {
                emoji = '👍';
            } else {
                emoji = '🚀';
            }
            
            // Show results
            showResults('Success', `
                <h3>${emoji} Mission Complete! ${emoji}</h3>
                <p>You've successfully delivered packages to all planets and returned to ${gameState.startPlanet.name}.</p>
                <p>Total fuel used: <strong>${totalFuel} units</strong></p>
                <p>Optimal route would use approximately: <strong>${optimalFuel} units</strong></p>
                <p>Fuel efficiency rating: <strong>${rating} (${efficiency}%)</strong></p>
                <p>Your Route: ${generateRouteSummary()}</p>
            `, true);
        }
        
        // Generate a text summary of the route
        function generateRouteSummary() {
            return gameState.currentRoute.map(planet => planet.name).join(' → ');
        }
        
        // Show results
        function showResults(status, message, showModal = false) {
            resultsContent.innerHTML = message;
            resultsContent.style.display = 'block';
            
            if (showModal) {
                modalResultsContent.innerHTML = message;
                resultsModal.style.display = 'flex';
            }
        }
        
        // Reset the route
        function resetRoute() {
            // Clear the current route except for the starting planet
            while (gameState.currentRoute.length > 1) {
                const planet = gameState.currentRoute.pop();
                planet.element.classList.remove('selected');
            }
            
            // Clear selected paths
            gameState.selectedPaths.forEach(path => {
                mapContainer.removeChild(path);
            });
            gameState.selectedPaths = [];
            
            // Reset fuel counter
            fuelCounter.textContent = '0';
            
            // Update the route display
            updateRouteDisplay();
            
            // Hide results
            resultsContent.style.display = 'none';
            
            // Show notification
            showNotification('Route reset! Select your next destination.');
        }
        
        // Generate an approximate optimal route using a simple greedy algorithm
        function generateOptimalRoute() {
            // Start from the start planet
            let current = gameState.startPlanet;
            let remainingPlanets = [...gameState.planets].filter(p => p !== current);
            let route = [current];
            let totalCost = 0;
            
            // Greedy algorithm - always choose the closest unvisited planet
            while (remainingPlanets.length > 0) {
                // Find the closest planet
                let closestPlanet = null;
                let minCost = Infinity;
                
                for (const planet of remainingPlanets) {
                    const path = findPath(current, planet);
                    if (path && path.cost < minCost) {
                        minCost = path.cost;
                        closestPlanet = planet;
                    }
                }
                
                if (closestPlanet) {
                    // Add to route
                    route.push(closestPlanet);
                    totalCost += minCost;
                    
                    // Update for next iteration
                    current = closestPlanet;
                    remainingPlanets = remainingPlanets.filter(p => p !== closestPlanet);
                } else {
                    // Shouldn't happen in a fully connected graph
                    break;
                }
            }
            
            // Return to start
            const finalPath = findPath(current, gameState.startPlanet);
            if (finalPath) {
                route.push(gameState.startPlanet);
                totalCost += finalPath.cost;
            }
            
            // Store the optimal route
            gameState.optimalRoute = {
                route: route,
                cost: totalCost
            };
        }
        

        }
